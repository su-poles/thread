package com.poles.day3;

/**
*********************************************************************
* 
* @author poles
* @date 2019-05-20 19:46
* @desc 
*
*********************************************************************
*/
public class Note {
    /**
     * 原子性：原子性是指一个操作是不可中断的，即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰。要么完成，要么就完不成。不会出现中间状态。
     *
     * i++是原子操作吗： 首先要读，然后要++，最后要赋值
     *
     * 32位操作系统上去给一个64位的数据类型进行操作：比如在32位的java虚拟机上对一个long类型的变量进行操作，也是非原子性的
     */

    /**
     *
     * 有序性：在并发时，程序的执行可能就会出现乱序
     *     class OrderExample {
     *         int a = 0;
     *         boolean flag = false;
     *
     *         public void writer() {
     *             a = 1;
     *             flag = true;
     *         }
     *
     *         public void reader() {
     *             if (flag) {
     *                 int i = a + 1;
     *                 ......
     *             }
     *         }
     *     }
     *
     * 指令重排可以使流水线更加顺畅
     */

    /**
     * 可见性：是指当一个线程修改了某一个共享变量的值，其它线程是否能够立即知道这个修改。
     *
     * 各个级别上都有可能导致可见性问题，  CPU的重排序可能导致重排序， 编译器优化时也可能存在可见性问题
     *
     * 编译器优化：
     * 硬件优化（如写吸收、批操作）：  假设计算有很多次计算，中间每次计算完之后CPU都要给内存中赋值，
     * 为了优化速度，CPU每次的计算后的值都放在cache队列中，然后等队列出发某个条件之后批量写入内存中，
     * 这样会提高写入内存中的效率。 多次计算，中间每次存值其实都是没有意义的，不管计算多少次，实际上都是以最后一次为准
     * 所以为了优化这个速度，那么中间每次"需要存储"的指令就可以"优化"掉了，那么对于其他线程来说，中间的很多结果都看不见，这就
     * 也造成了一种"可见性"问题
     *
     * 多核CPU之间有一种可见性协议，但是这种协议都比较松散
     * 比如多个CPU同时操作内存中的变量t, 那么CPU1可能会拷贝一个副本到cache 中进行操作，那么CPU2针对内存中t的操作，CPU1可能没那么快看见
     * 如果所有CPU都直接操作内存变量，那么cache就等于没用了....因此，保证内存可见性需要牺牲一定程度的性能
     *
     * 换句话说：如果没有优化，就不会有可见性问题，但是如果没有优化，那么性能就会很差。
     *
     * Java虚拟机层面的可见性：http://hushi55.github.io/2015/01/05/volatile-assembly
     *
     * VisibilityTest  这个类就是上述这个博客中的，请看一下这个类，为什么这个类就是不会结束呢？
     * （目前大多数64位的虚拟机默认是以-server模式开启的，如果是以-client模式开启的，那就是我们所想的步骤和预期的结果）
     * -server由于优化内容比较多，结果stop这个值就只在最开始时读了一次，并不是每次都读取stop的值，所以即使后面我们对stop重新赋值之后
     * 虚拟机依然没有读取stop的值去作比较，导致while循环一直执行。这也就是虚拟机优化导致的一个可见性问题的案例
     *
     * 如何解决这个问题呢：将 "private boolean stop;" 改为 "private volatile boolean stop;"
     * volatile 在 JVM 内存模型中是保证修饰变量的可见性
     *
     */


    /**
     * Happen-Before规则
     *
     * 1. 程序顺序原则：一个线程内保证语义的串行性：   a=1; b=a+1;
     * 2. volatile规则:volatile变量的写，先发生于读，这保证了volatile变量的可见性  锁规则:解锁(unlock)必然发生在随后的加锁(lock)前
     * 3. 传递性:A先于B，B先于C，那么A必然先于C
     * 4. 线程的start()方法先于它的每一个动作
     * 5. 线程的所有操作先于线程的终结(Thread.join())
     * 6. 线程的中断(interrupt())先于被中断线程的代码
     * 7. 对象的构造函数执行结束先于finalize()方法
     */

    /**
     * 线程安全：指某个函数、函数库在多环境中被调用时，能够正确地处理各个线程的局部变量，使程序功能正确完成。
     */


}
